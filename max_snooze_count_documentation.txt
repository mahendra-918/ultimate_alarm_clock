Max Snooze Count Feature

What I Built
I implemented a max snooze count feature that prevents users from snoozing their alarms indefinitely. Users can now set a limit (1-10 times) on how many times they can snooze an alarm, ensuring they eventually wake up while still providing some flexibility.

Why This Feature Matters
The biggest problem with alarm apps is infinite snoozing - users hit snooze repeatedly and end up oversleeping. This creates:
- Chronic lateness and missed appointments
- Disrupted sleep patterns
- Reduced alarm effectiveness over time
- Stress from constantly oversleeping

Max snooze count solves this by giving users controlled flexibility. They can still snooze a few times for those difficult mornings, but the alarm eventually forces them to wake up.

How It Works
Users can set a maximum snooze limit when creating or editing alarms. The system tracks how many times they've snoozed and prevents further snoozing once the limit is reached.

Key Features:
- Configurable limit from 1-10 snoozes (default: 3)
- Real-time counter showing "Snooze X/Y" during alarm
- Visual feedback when limit is reached
- Prevention of further snoozing with user-friendly message
- Integration with existing snooze duration settings

User Experience:
1. User sets max snooze count in alarm settings (e.g., 3 times)
2. When alarm rings, they see "Snooze 0/3" below the snooze button
3. Each snooze increments the counter: "Snooze 1/3", "Snooze 2/3"
4. After reaching the limit, snooze button shows "Max Snooze Limit" message
5. User must either dismiss or let the alarm continue ringing

Technical Implementation
I built this feature across multiple layers with proper state management and data persistence.

Data Model:
- Added maxSnoozeCount field to AlarmModel (default: 3)
- Integrated with both SQLite and Firestore databases
- Included in all serialization and migration logic

UI Components:
I created two complementary interfaces:
1. MaxSnoozeCountTile: Standalone component with NumberPicker (1-10 range)
2. SnoozeSettingsTile: Combined interface for duration and count settings

Both provide dialog-based configuration with proper state management and rollback on cancellation.

Enforcement Logic:
The core enforcement happens in AlarmControlController during snooze attempts:

```dart
void startSnooze() async {
  int actualMaxSnoozeCount = currentlyRingingAlarm.value.maxSnoozeCount;
  
  // Fetch fresh data to prevent stale state
  if (currentlyRingingAlarm.value.isarId > 0) {
    final dbAlarm = await IsarDb.getAlarm(currentlyRingingAlarm.value.isarId);
    if (dbAlarm != null) {
      actualMaxSnoozeCount = dbAlarm.maxSnoozeCount;
    }
  }
  
  if (snoozeCount.value >= actualMaxSnoozeCount) {
    Get.snackbar("Max Snooze Limit", "You've reached the maximum snooze limit");
    return;
  }
  snoozeCount.value++;
  // Continue with snooze logic
}
```

State Management:
- Uses GetX reactive programming for real-time UI updates
- RxInt snoozeCount tracks current snooze attempts
- RxInt maxSnoozeCount manages the configured limit
- Automatic UI updates when values change

Visual Feedback:
The alarm ring view displays current progress:
- "Snooze 0/3" initially
- Updates to "Snooze 1/3", "Snooze 2/3" as user snoozes
- Shows snackbar message when limit is reached
- Prevents further snoozing attempts

Challenges I Solved

1. Data Consistency
Ensuring the max snooze count stays synchronized between the alarm configuration and the active alarm session. I solved this by fetching fresh data from the database during each snooze attempt.

2. State Management
Managing both current snooze count and maximum limit across different controllers and UI components. Used GetX observables for reactive updates.

3. User Experience
Providing clear visual feedback about snooze progress without cluttering the UI. The "X/Y" format is intuitive and doesn't interfere with existing alarm functionality.

4. Database Integration
Adding the new field to existing alarm models while maintaining backward compatibility. Implemented proper default values and migration logic.

5. Edge Cases
Handling scenarios like alarm modification while active, database failures, and state restoration after app restarts.

Code Architecture
I implemented the feature across multiple architectural layers:

Data Layer:
- alarm_model.dart: Added maxSnoozeCount field with default value 3
- isar_provider.dart: Database schema updates and migration
- Firestore integration: Cloud storage with null-safe fallbacks

UI Layer:
- max_snooze_count_tile.dart: Standalone configuration component
- snooze_settings_tile.dart: Combined settings interface
- alarm_ring_view.dart: Real-time counter display

Controller Layer:
- add_or_update_alarm_controller.dart: Configuration state management
- alarm_ring_controller.dart: Enforcement logic and snooze tracking

Results
Users now have meaningful control over their snoozing behavior. The feature provides the right balance between flexibility (allowing some snoozes for difficult mornings) and discipline (preventing infinite snoozing).

Real-World Impact:
- Prevents chronic oversleeping by enforcing limits
- Maintains alarm effectiveness over time
- Reduces morning stress and anxiety about oversleeping
- Helps users develop better waking habits

The feature demonstrates how small UX improvements can have significant behavioral impact. By adding just a simple counter and limit, users gain much better control over their morning routines.

Development Details
- Implemented in commit 6874d25 "added max snooze"
- Pull request #816 "maxSnoozeCount Feature Implementation"
- 7 files modified with 543 lines added
- Full integration with existing snooze system
- Comprehensive UI and backend implementation

Technical Highlights:
- Range validation (1-10 times)
- Real-time state synchronization
- Database schema evolution
- User-friendly error handling
- Clean separation of concerns between UI and logic