# Ultimate Alarm Clock - Kotlin Database Functions Reference

## Overview
This document provides a comprehensive reference for all Kotlin functions available in the Ultimate Alarm Clock app for accessing alarm data from the database. These functions are primarily located in the Android native code and can be called via method channels from Flutter.

## Primary Database Functions

### 1. getLatestAlarm()
**Location:** `GetLatestAlarm.kt`
**Purpose:** Fetches the next upcoming alarm from the SQLite database
**Returns:** AlarmModel object or null

```kotlin
fun getLatestAlarm(context: Context): AlarmModel? {
    val dbHelper = DatabaseHelper(context)
    val db = dbHelper.readableDatabase
    
    val cursor = db.query(
        "alarms",
        null,
        "isEnabled = 1 AND minutesSinceMidnight > ?",
        arrayOf(getCurrentMinutes().toString()),
        null, null,
        "minutesSinceMidnight ASC",
        "1"
    )
    
    return if (cursor.moveToFirst()) {
        AlarmModel.fromCursor(cursor)
    } else {
        null
    }
}
```

### 2. determineNextAlarm()
**Location:** `AlarmUtils.kt`
**Purpose:** Gets the best available alarm (comparing local and shared)
**Returns:** Best AlarmModel available

```kotlin
fun determineNextAlarm(context: Context): AlarmModel? {
    val localAlarm = getLatestAlarm(context)
    val sharedAlarm = checkActiveSharedAlarm(context)
    
    return when {
        localAlarm != null && sharedAlarm != null -> {
            if (localAlarm.minutesSinceMidnight <= sharedAlarm.minutesSinceMidnight) localAlarm else sharedAlarm
        }
        localAlarm != null -> localAlarm
        sharedAlarm != null -> sharedAlarm
        else -> null
    }
}
```

### 3. checkActiveSharedAlarm()
**Location:** `AlarmUtils.kt`
**Purpose:** Checks SharedPreferences for active shared alarm
**Returns:** AlarmModel from shared preferences or null

```kotlin
fun checkActiveSharedAlarm(context: Context): AlarmModel? {
    val sharedPreferences = context.getSharedPreferences("FlutterSharedPreferences", Context.MODE_PRIVATE)
    val hasActiveSharedAlarm = sharedPreferences.getBoolean("flutter.has_active_shared_alarm", false)
    
    if (hasActiveSharedAlarm) {
        val alarmId = sharedPreferences.getString("flutter.shared_alarm_id", null)
        val alarmTime = sharedPreferences.getString("flutter.shared_alarm_time", null)
        // ... construct and return AlarmModel
    }
    return null
}
```

## Utility Functions

### Time Calculation Functions
```kotlin
// Calculate milliseconds until next alarm
fun getTimeDifferenceInMillis(alarmTime: String): Long

// Get time difference from midnight in minutes
fun getTimeDifferenceFromMidnight(hour: Int, minute: Int): Int

// Convert time string to minutes since midnight
fun timeStringToMinutes(timeString: String): Int

// Get current time in minutes since midnight
fun getCurrentMinutes(): Int
```

### Day Calculation Functions
```kotlin
// Calculate days until next alarm occurrence
fun getDaysUntilNextAlarm(alarmDays: String, currentDay: Int): Int

// Get days from current date
fun getDaysFromCurrentDate(targetDays: String): Int

// Check if alarm should ring today
fun shouldAlarmRingToday(alarmDays: String): Boolean
```

## Database Infrastructure

### DatabaseHelper Class
```kotlin
class DatabaseHelper(context: Context) : SQLiteOpenHelper(context, "alarms.db", null, 4) {
    
    override fun onCreate(db: SQLiteDatabase) {
        // Creates alarms table with all required columns
    }
    
    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
        // Handles database schema updates
    }
    
    fun getAllEnabledAlarms(): List<AlarmModel> {
        // Returns all enabled alarms
    }
    
    fun getAlarmById(alarmId: String): AlarmModel? {
        // Gets specific alarm by ID
    }
}
```

### AlarmModel Data Class
```kotlin
data class AlarmModel(
    val alarmId: String,
    val alarmTime: String,
    val isEnabled: Boolean,
    val minutesSinceMidnight: Int,
    val days: String,
    val isSharedAlarmEnabled: Boolean,
    val firestoreId: String?,
    val ownerId: String?,
    val location: String?,
    val note: String,
    val label: String
) {
    companion object {
        fun fromCursor(cursor: Cursor): AlarmModel {
            return AlarmModel(
                alarmId = cursor.getString(cursor.getColumnIndexOrThrow("alarmID")),
                alarmTime = cursor.getString(cursor.getColumnIndexOrThrow("alarmTime")),
                isEnabled = cursor.getInt(cursor.getColumnIndexOrThrow("isEnabled")) == 1,
                minutesSinceMidnight = cursor.getInt(cursor.getColumnIndexOrThrow("minutesSinceMidnight")),
                days = cursor.getString(cursor.getColumnIndexOrThrow("days")),
                isSharedAlarmEnabled = cursor.getInt(cursor.getColumnIndexOrThrow("isSharedAlarmEnabled")) == 1,
                firestoreId = cursor.getString(cursor.getColumnIndexOrThrow("firestoreId")),
                ownerId = cursor.getString(cursor.getColumnIndexOrThrow("ownerId")),
                location = cursor.getString(cursor.getColumnIndexOrThrow("location")),
                note = cursor.getString(cursor.getColumnIndexOrThrow("note")),
                label = cursor.getString(cursor.getColumnIndexOrThrow("label"))
            )
        }
    }
}
```

## Timer Functions

### Timer Database Access
**Location:** `TimerFunctions.kt`
```kotlin
fun getLatestTimer(context: Context): TimerModel?
fun getAllActiveTimers(context: Context): List<TimerModel>
fun updateTimerElapsed(context: Context, timerId: Int, elapsed: Long)
```

## Method Channel Integration

### Flutter to Kotlin Communication
```kotlin
// In MainActivity.kt
methodChannel.setMethodCallHandler { call, result ->
    when (call.method) {
        "getLatestAlarm" -> {
            val alarm = getLatestAlarm(this)
            result.success(alarm?.toMap())
        }
        "getAllEnabledAlarms" -> {
            val alarms = DatabaseHelper(this).getAllEnabledAlarms()
            result.success(alarms.map { it.toMap() })
        }
        "determineNextAlarm" -> {
            val nextAlarm = determineNextAlarm(this)
            result.success(nextAlarm?.toMap())
        }
    }
}
```

## Usage Examples

### Getting Next Alarm for Watch Display
```kotlin
fun getNextAlarmForWatch(): Map<String, Any>? {
    val nextAlarm = determineNextAlarm(context)
    return nextAlarm?.let { alarm ->
        mapOf(
            "time" to alarm.alarmTime,
            "label" to alarm.label,
            "daysUntil" to getDaysUntilNextAlarm(alarm.days, getCurrentDay()),
            "isShared" to alarm.isSharedAlarmEnabled,
            "note" to alarm.note
        )
    }
}
```

### Checking if Alarms Exist
```kotlin
fun hasActiveAlarms(): Boolean {
    val dbHelper = DatabaseHelper(context)
    val count = dbHelper.getEnabledAlarmsCount()
    return count > 0
}
```

## Data Structures

### Return Data Format
```json
{
  "alarmId": "uuid-string",
  "alarmTime": "HH:MM",
  "label": "Alarm Label",
  "note": "Alarm Note", 
  "isEnabled": true,
  "days": "1111100", // Mon-Sun binary
  "minutesSinceMidnight": 420,
  "isSharedAlarmEnabled": false,
  "location": "Location Name",
  "timeUntilAlarm": 86400000 // milliseconds
}
```

## Implementation Notes

1. **Database Path:** `/data/data/com.ccextractor.ultimate_alarm_clock/databases/alarms.db`
2. **Shared Preferences Key:** `FlutterSharedPreferences`
3. **Thread Safety:** All database operations should be performed on background threads
4. **Error Handling:** Always check for null cursors and handle SQLite exceptions
5. **Performance:** Use prepared statements for repeated queries
6. **Memory Management:** Always close cursors and database connections

## For Watch Companion Development

### Essential Functions for Watch Integration
```kotlin
// Primary function - gets next alarm regardless of type
fun getNextAlarmForWatch(): AlarmModel? = determineNextAlarm(context)

// Alternative - get all enabled alarms for watch display
fun getAllActiveAlarmsForWatch(): List<AlarmModel> {
    return DatabaseHelper(context).getAllEnabledAlarms()
        .filter { it.isEnabled }
        .sortedBy { it.minutesSinceMidnight }
}

// Check if alarm will ring within timeframe
fun willAlarmRingWithin(minutes: Int): Boolean {
    val nextAlarm = getNextAlarmForWatch()
    return nextAlarm?.let { 
        val timeToAlarm = getTimeDifferenceInMillis(it.alarmTime)
        timeToAlarm <= (minutes * 60 * 1000)
    } ?: false
}
```

---

## ðŸŽ¯ **WATCH COMPANION APP RECOMMENDATIONS**

### **Advanced Features Your Friend Should Consider**

### 1. **Smart Battery Management**
```kotlin
class WatchBatteryOptimizer {
    companion object {
        private var lastSyncTime = 0L
        private const val MIN_SYNC_INTERVAL = 30000L // 30 seconds
        
        fun shouldSync(): Boolean {
            val now = System.currentTimeMillis()
            return (now - lastSyncTime) > MIN_SYNC_INTERVAL
        }
        
        fun optimizeUpdateFrequency(batteryLevel: Int): Long {
            return when {
                batteryLevel < 20 -> 300000L // 5 minutes when low battery
                batteryLevel < 50 -> 120000L // 2 minutes when medium battery  
                else -> 60000L // 1 minute when high battery
            }
        }
    }
}
```

### 2. **Real-Time Bidirectional Sync**
```kotlin
class WatchSyncService {
    fun initializeBidirectionalSync() {
        // Listen for phone app changes
        setupPhoneListener()
        
        // Listen for watch-initiated changes
        setupWatchListener()
        
        // Handle conflict resolution
        setupConflictResolver()
    }
    
    private fun setupConflictResolver() {
        // Last-write-wins with timestamp comparison
        // Or user-preference based resolution
    }
}
```

### 3. **Watch-Specific UI Optimizations**
```kotlin
class WatchAlarmDisplay {
    fun getOptimizedAlarmList(): List<WatchAlarmItem> {
        val alarms = getAllActiveAlarmsForWatch()
        
        return alarms.take(5).map { alarm -> // Limit to 5 for watch screen
            WatchAlarmItem(
                timeDisplay = formatTimeForWatch(alarm.alarmTime),
                shortLabel = alarm.label.take(15), // Truncate for watch
                timeUntil = calculateTimeUntilDisplay(alarm),
                priority = calculatePriority(alarm)
            )
        }
    }
    
    private fun formatTimeForWatch(alarmTime: String): String {
        // Format optimized for small watch screen
        return if (is24HourFormat()) alarmTime else convertTo12Hour(alarmTime)
    }
}
```

### 4. **Offline Capabilities**
```kotlin
class WatchOfflineManager {
    private val pendingActions = mutableListOf<WatchAction>()
    
    fun queueAction(action: WatchAction) {
        pendingActions.add(action)
        saveToLocalStorage(action)
    }
    
    fun syncPendingActions() {
        pendingActions.forEach { action ->
            try {
                sendToPhone(action)
                removePendingAction(action)
            } catch (e: Exception) {
                // Keep in queue for next sync attempt
            }
        }
    }
}
```

### 5. **Interactive Watch Features**
```kotlin
class WatchInteractions {
    fun enableQuickActions() {
        // Swipe gestures for common actions
        setupSwipeToSnooze()
        setupTapToToggle()
        setupLongPressForDetails()
    }
    
    private fun setupSwipeToSnooze() {
        // Implement swipe gesture to snooze next alarm
    }
    
    private fun setupTapToToggle() {
        // Quick toggle alarm on/off
    }
    
    fun createAlarmFromWatch(timeInput: String, labelInput: String) {
        val newAlarm = WatchAlarmCreator.createAlarm(timeInput, labelInput)
        sendToPhoneApp(newAlarm)
    }
}
```

### 6. **Performance Monitoring**
```kotlin
class WatchPerformanceMonitor {
    companion object {
        fun trackSyncLatency(startTime: Long) {
            val latency = System.currentTimeMillis() - startTime
            if (latency > 5000) { // Log if sync takes more than 5 seconds
                Log.w("WatchSync", "Slow sync detected: ${latency}ms")
            }
        }
        
        fun monitorMemoryUsage() {
            val runtime = Runtime.getRuntime()
            val usedMemory = runtime.totalMemory() - runtime.freeMemory()
            if (usedMemory > 50 * 1024 * 1024) { // 50MB threshold
                triggerMemoryCleanup()
            }
        }
    }
}
```

### **Key Integration Points**

1. **Method Channel Setup:**
```kotlin
class WatchMethodChannel {
    companion object {
        const val CHANNEL_NAME = "watch_alarm_sync"
        
        fun setupChannel(activity: FlutterActivity) {
            MethodChannel(activity.flutterEngine!!.dartExecutor.binaryMessenger, CHANNEL_NAME)
                .setMethodCallHandler { call, result ->
                    when (call.method) {
                        "getWatchAlarmData" -> result.success(getWatchOptimizedData())
                        "updateAlarmFromWatch" -> handleWatchUpdate(call.arguments)
                        "getWatchBatteryOptimizedSync" -> result.success(getBatteryOptimizedSyncInterval())
                    }
                }
        }
    }
}
```

### **Missing Considerations**

1. **User Preferences Sync:**
   - 12/24 hour format
   - Snooze duration preferences
   - Theme/color preferences

2. **Smart Notifications:**
   - Different notification styles for different alarm types
   - Priority-based notification handling
   - Do not disturb integration

3. **Health Integration:**
   - Sleep tracking integration
   - Smart wake-up during light sleep phases
   - Heart rate monitoring for stress-based alarm adjustments

4. **Accessibility:**
   - Voice commands for alarm control
   - Haptic feedback patterns
   - Large text support

---

This comprehensive reference should give your friend everything needed to build a robust watch companion app with real-time synchronization and advanced features! 